<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="richTextBox1.Text" xml:space="preserve">
    <value>안녕 도트 툴 없는 친구들!

내 툴을 사용하기 편하도록 몇 가지 도움을 주려고 해.

기능 소개니까 툴을 최대한 활용하려면 잘 봐둬!


주의사항!

1. 본 프로그램은 매우 구닥다리이므로 100*100 px만 되어도 견딜 수가 없습니다. 작은 도트용으로만 사용하시기 바랍니다. 

2. 본 프로그램은 세이브 권유를 하지 않습니다. 실수로 나가지 않게 주의하십시오.


Main 화면

Pencil Case 버튼:  필통을 불러옵니다.

Width 칸: 새로 파일을 만들 때 설정할 가로 너비를 입력하는 칸 입니다.

Heitght 칸: 새로 파일을 만들 때 설정한 세로 너비를 입력하는 칸 입니다.

New 버튼: 새로 파일을 만들 위치를 선택합니다. (지원 포맷 *.png)

Load 버튼: 불러올 기존 파일을 선택합니다. (지원 포맷 *.png)

New 혹은 Load 버튼을 누르면 BitMap화면으로 넘어가며 작업을 시작하실 수 있습니다.


BitMap 화면

클릭: 해당 비트에서 작업을 수행합니다.

더블 클릭: 연속 선 긋기 모드가 되어, 마우스 버튼을 떼고 있어도 연속으로 선이 그어집니다.


Pencil Case 화면(중요!)

Border 버튼: BitMap 화면에 격자 무늬를 표시합니다.

Extrain 버튼(활성화): BitMap의 비트에서 색상을 추출하여 현재 색상에 대입합니다.

Paint 버튼(활성화): BitMap의 해당 비트와 직접 연결된 색상이 같은 모든 비트에 현재 색상을 칠합니다.

Mirror 버튼(활성화/2단계(수평/수직)): 수평/수직 대칭자를 설치하여 대칭으로 그림을 자동으로 그려줍니다.

색상 네모와 RGBA값: 현재 색상과 RGBA값을 표시합니다.

Smart Set 버튼: ColorDialog를 통한 현재 색상 값을 재설정합니다.

Save 버튼: 현재 BitMap을 저장합니다.

Export 버튼: 옆의 숫자만큼 배율을 설정하여 현재 BitMap을 저장합니다.

Combine 버튼: 기존의 *.png 파일들을 합쳐줍니다. 옆에 입력된 가로와 세로 값 만큼 같은 크기의 *.png 파일을 합쳐서 다시 저장합니다.</value>
  </data>
</root>